//@author: a0100720e



	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\DataUI.java
	 */

package application;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * this class processes the information that has been handled by the logic
 * and passes it back to the GUI for printing on the GUI
 * 
 * Things to take note of:
 * 		- depending on the command type, it will process the info
 * 		- needs attributes to tell which command
 * 
 * format of processing
 * Events: ID, Priority, Name, Start Date, Start Time, End Date, End Time, Frequency
 * Tasks: ID, Priority, Name, End Date, End Time
 *
 */

public class DataUI {

	private static final String DEFAULT_FEEDBACK = "Read me!";
	private SimpleDateFormat timeFormat = new SimpleDateFormat("h:mmaa");
	private SimpleDateFormat dateFormat = new SimpleDateFormat("d MMM yyyy");	
	private SimpleDateFormat timeUIFormat = new SimpleDateFormat("EEE h:mmaa");
	
	private ArrayList<TaskDataUI> incompleteTasks;
	private ArrayList<TaskDataUI> completeTasks;
	private ArrayList<EventDataUI> incompleteEvents;
	private ArrayList<EventDataUI> completeEvents;
	private ArrayList<EventDataUI> helpEvents;
	private String UIclock;
	private String UIdate;
	
	private String feedback = DEFAULT_FEEDBACK;
	private int row_added;
	private int file_added;
	
	/**
	 * Constructor for DataUI
	 * Takes in an integer and calls the appropriate methods within DataUI
	 * to arrange the information for the GUI to print it out
	 * @param
	 * int cmdType: indicates the command type
	 */
	public DataUI() {
		incompleteTasks = new ArrayList<TaskDataUI>();
		incompleteEvents = new ArrayList<EventDataUI>();
		completeTasks = new ArrayList<TaskDataUI>();
		completeEvents = new ArrayList<EventDataUI>();
		helpEvents = new ArrayList<EventDataUI>();
	}
	
	/**
	 * Incomplete Task 
	 * @param fileLink
	 * 
	 */
	public void configIncompleteTasks(FileLinker fileLink) {
		incompleteTasks = new ArrayList<TaskDataUI>();
		ArrayList<TaskCard> incompTasks = fileLink.getIncompleteTasks();
				
		for(int i = 1; i <= incompTasks.size(); i++) {
			TaskDataUI taskData = new TaskDataUI();
			TaskCard task = incompTasks.get(i - 1);
			
			taskData.setID("" + i);
			String priority = determinePriority(task.getPriority());
			taskData.setPriority("" + priority);
			taskData.setName(task.getName());
			if(task.getType().equals("FT")){
				taskData.setEndTime("-");
				taskData.setEndDate("-");
			} else {
				Calendar endDay = task.getEndDay();
				Calendar now = GregorianCalendar.getInstance();
				
				if(endDay.before(now) || endDay.equals(now)) {
					taskData.setIsExpired(true);
				} else {
					taskData.setIsExpired(false);
				}
				
				taskData.setEndDate(dateFormat.format(endDay.getTime()));
				
				if(endDay.get(Calendar.HOUR_OF_DAY) == 0 && endDay.get(Calendar.MINUTE) == 0) {
					taskData.setEndTime("-");
				} else {
					taskData.setEndTime(timeFormat.format(endDay.getTime()));
				}
			}
			
			incompleteTasks.add(taskData);
		}
	}

	/**
	 * For incomplete Events
	 * @param fileLink
	 */
	public void configIncompleteEvents(FileLinker fileLink) {
		incompleteEvents = new ArrayList<EventDataUI>();
		ArrayList<TaskCard> incompEvents = fileLink.getIncompleteEvents();
		
		for(int i = 1; i <= incompEvents.size(); i++) {
			EventDataUI eventData = new EventDataUI();
			TaskCard event = incompEvents.get(i - 1);
			
			eventData.setID("" + i);
			eventData.setName(event.getName());
			String priority = determinePriority(event.getPriority());
			eventData.setPriority("" + priority);
			
			if(event.getType().equals("AE")) {
				Calendar startDay = event.getStartDay();
				Calendar endDay = event.getEndDay();
				eventData.setStartDate(dateFormat.format(startDay.getTime())); //start date
				eventData.setStartTime("-"); //no start time
				eventData.setEndDate(dateFormat.format(endDay.getTime())); //end date	
				eventData.setEndTime("-"); //no end time
			} else {
				Calendar startDay = event.getStartDay();
				Calendar endDay = event.getEndDay();
				eventData.setStartDate(dateFormat.format(startDay.getTime()));
				eventData.setStartTime(timeFormat.format(startDay.getTime()));
				eventData.setEndDate(dateFormat.format(endDay.getTime()));
				eventData.setEndTime(timeFormat.format(endDay.getTime()));
			}
			
			Calendar now = GregorianCalendar.getInstance();
			
			if(event.getEndDay().before(now) || event.getEndDay().equals(now)) {
				eventData.setIsExpired(true);
			}
			
			if(event.getStartDay().before(now) && event.getEndDay().after(now)) {
				eventData.setIsOngoing(true);
			}
			
			incompleteEvents.add(eventData);
		}
	}

	/**
	 * Complete Task 
	 * @param fileLink
	 * 
	 */
	public void configCompleteTasks(FileLinker fileLink) {
		completeTasks = new ArrayList<TaskDataUI>();
		ArrayList<TaskCard> incompTasks = fileLink.getCompletedTasks();
				
		for(int i = 1; i <= incompTasks.size(); i++) {
			TaskDataUI taskData = new TaskDataUI();
			TaskCard task = incompTasks.get(i - 1);
			
			taskData.setID("" + i);
			String priority = determinePriority(task.getPriority());
			taskData.setPriority("" + priority);
			taskData.setName(task.getName());
			if(task.getType().equals("FT")){
				taskData.setEndTime("-");
				taskData.setEndDate("-");
			} else {
				Calendar endDay = task.getEndDay();
				
				taskData.setEndDate(dateFormat.format(endDay.getTime()));
				
				if(endDay.get(Calendar.HOUR_OF_DAY) == 0 && endDay.get(Calendar.MINUTE) == 0) {
					taskData.setEndTime("-");
				} else {
					taskData.setEndTime(timeFormat.format(endDay.getTime()));
				}
			}
			
			completeTasks.add(taskData);
		}
	}
	
	
	/**
	 * For Completed Events
	 * @param fileLink
	 */
	public void configCompletedEvents(FileLinker fileLink) {
		completeEvents = new ArrayList<EventDataUI>();
		ArrayList<TaskCard> incompEvents = fileLink.getCompletedEvents();
		
		for(int i = 1; i <= incompEvents.size(); i++) {
			EventDataUI eventData = new EventDataUI();
			TaskCard event = incompEvents.get(i - 1);
			
			eventData.setID("" + i);
			eventData.setName(event.getName());
			String priority = determinePriority(event.getPriority());
			eventData.setPriority("" + priority);
			
			if(event.getType().equals("AE")) {
				Calendar startDay = event.getStartDay();
				Calendar endDay = event.getEndDay();
				eventData.setStartDate(dateFormat.format(startDay.getTime())); //start date
				eventData.setStartTime("-"); //no start time
				eventData.setEndDate(dateFormat.format(endDay.getTime())); //end date	
				eventData.setEndTime("-"); //no end time
			} else {
				Calendar startDay = event.getStartDay();
				Calendar endDay = event.getEndDay();
				eventData.setStartDate(dateFormat.format(startDay.getTime()));
				eventData.setStartTime(timeFormat.format(startDay.getTime()));
				eventData.setEndDate(dateFormat.format(endDay.getTime()));
				eventData.setEndTime(timeFormat.format(endDay.getTime()));
			}
			
			completeEvents.add(eventData);
		}
	}
	
	public void configHelpEvents() {
		EventDataUI helpEvent1 = new EventDataUI();
		EventDataUI helpEvent2 = new EventDataUI();
		
		helpEvent1.setID("1");
		helpEvent1.setName("Expired events are highlighted in red.");
		helpEvent1.setPriority("HIGH");
		helpEvent1.setStartDate("-");
		helpEvent1.setStartTime("-");
		helpEvent1.setEndDate("-");
		helpEvent1.setEndTime("-");
		helpEvent1.setIsExpired(true);
		helpEvent1.setIsOngoing(false);
		
		helpEvent2.setID("2");
		helpEvent2.setName("Ongoing events are highlighted in blue.");
		helpEvent2.setPriority("LOW");
		helpEvent2.setStartDate("-");
		helpEvent2.setStartTime("-");
		helpEvent2.setEndDate("-");
		helpEvent2.setEndTime("-");
		helpEvent2.setIsExpired(false);
		helpEvent2.setIsOngoing(true);
		
		helpEvents.add(helpEvent1);
		helpEvents.add(helpEvent2);
	}
	
	private String determinePriority(int priority) {
		if(priority == 1) {
			return "LOW";
		} else if(priority == 2) {
			return "MED";
		} else
			return "HIGH";
	}
	
	public ArrayList<TaskDataUI> getIncompleteTasks() {
		return incompleteTasks;
	}
		
	public ArrayList<EventDataUI> getIncompleteEvents() {
		return incompleteEvents;
	}
	
	public ArrayList<TaskDataUI> getCompleteTasks() {
		return completeTasks;
	}
	
	public ArrayList<EventDataUI> getCompleteEvents() {
		return completeEvents;
	}
	
	public ArrayList<EventDataUI> getHelpEvents() {
		configHelpEvents();
		return helpEvents;
	}
	
	public String getFeedback() {
		return feedback;
	}
	
	public void setFeedback(String message) {
		feedback = message;
	}
	
	public int getRowAdded() {
		return row_added;
	}
	
	public int getFileAdded() {
		return file_added;
	}
	
	public void setRowAdded(int added) {
		row_added = added;
	}
	
	public void setFileAdded(int added) {
		file_added = added;
	}
	
	public String getUIClock() {
		return UIclock;
	}
	
	public void setUIclock(Calendar now) {
		Date clock = now.getTime();
		UIclock = timeUIFormat.format(clock);
	}
	
	public String getUIdate() {
		return UIdate;
	}
	
	public void setUIdate(Calendar now) {
		Date date = now.getTime();
		UIdate = dateFormat.format(date);
	}
}

	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\DataUI.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Delete.java
	 */

package application;
import java.util.ArrayList;
import java.util.HashMap;

public class Delete {
	
	private static final int DELETE_INCOMPLETE_TASKS = 1;
	private static final int DELETE_INCOMPLETE_EVENTS = 2;
	private static final int DELETE_COMPLETE_TASK = 3;
	private static final int DELETE_COMPLETE_EVENTS = 4;
	
	private static final int FIRST_ARGUMENT = 0;
	private static final int SECOND_ARGUMENT = 1;
		
	private static final String FEEDBACK_PENDING_INCOMPLETE_TASK_INDEX = "You seem to have forgotten something! Please enter an ID to delete!";
	private static final String FEEDBACK_PENDING_INCOMPLETE_EVENT_INDEX = "You seem to have forgotten something! Please enter an ID to delete!";
	private static final String FEEDBACK_PENDING_COMPLETE_TASK_INDEX = "You seem to have forgotten something! Please enter an ID to delete!";
	private static final String FEEDBACK_PENDING_COMPLETE_EVENT_INDEX = "You seem to have forgotten something! Please enter an ID to delete!";
	private static final String FEEDBACK_DELETE_SUCCESSFUL = "\"%s\" has been deleted!";
	private static final String FEEDBACK_DELETION_RANGE = "Please enter a number between 1 to %d!";
	private static final String FEEDBACK_UNRECOGNISABLE_DELETE_COMMAND = "That was an unrecognisable delete command :(";
	private static final String FEEDBACK_NOT_NUMBER_ENTERED = "You didn't enter a number! Please enter a number between 1 to %d!";
	
	private HashMap<String, Integer> cmdTable = new HashMap<String, Integer>();
	
	public Delete() {
		initialiseCmdTable();
	}

	/**
	 * This method checks if the program is currently in any delete error handling state
	 * if it is, it calls the individual delete methods
	 * else, it will identify what type of delete command the user has entered before
	 * handling the user input
	 * if errors still persist, it will remain in a state of error
	 * @param userInput
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler 
	 * @return
	 * the return type will signal to commandhandler whether the delete was successful
	 * or that there was an error involved
	 */
	public void executeDelete(String userInput, FileLinker fileLink, DataUI dataUI, int tableNo, Undo undoHandler) {
		boolean success = false;

		String[] tokenizedInput = userInput.trim().split("\\s+", 2);
		String cmd = tokenizedInput[FIRST_ARGUMENT];
			
		if(cmdTable.containsKey(cmd) != true) {
			notRecognisableCmd(fileLink, dataUI);
		} else {
			success = identifyCmdAndPerform(tokenizedInput, fileLink, dataUI, tableNo, undoHandler);
		}
		if(success) {
			undoHandler.flushRedo();
		}
	}
	
	/**
	 * This method checks if the command index is of acceptable length and checks what type of delete the user wishes to execute.
	 * It then redirects the input accordingly
	 * @param tokenizedInput
	 * @param fileLink
	 * @param dataUI
	 * @param tableNo
	 * @param undoHandler
	 * @return
	 */
	private boolean identifyCmdAndPerform(String[] tokenizedInput, FileLinker fileLink, DataUI dataUI, int tableNo, Undo undoHandler) {
		boolean success = false;
		boolean noIndexArgument = false;
		String userIndex = null;
		
		if(tokenizedInput.length < 2) {
			noIndexArgument = true;
		} else {
			userIndex = tokenizedInput[SECOND_ARGUMENT];
		}
		
		switch(tableNo) {
			case DELETE_INCOMPLETE_TASKS:
				if(noIndexArgument == true) {
					dataUI.setFeedback(FEEDBACK_PENDING_INCOMPLETE_TASK_INDEX);
					return success = false;
				} else {
					success = performIncTaskDelete(userIndex, fileLink, dataUI, undoHandler);
				}
				break;
			case DELETE_INCOMPLETE_EVENTS:
				if(noIndexArgument == true) {
					dataUI.setFeedback(FEEDBACK_PENDING_INCOMPLETE_EVENT_INDEX);
					return success = false;
				} else {
					success = performIncEventDelete(userIndex, fileLink, dataUI, undoHandler);
				}
				break;
			case DELETE_COMPLETE_TASK:
				if(noIndexArgument == true) {
					dataUI.setFeedback(FEEDBACK_PENDING_COMPLETE_TASK_INDEX);
					return success = false;
				} else {
					success = performCompTaskDelete(userIndex, fileLink, dataUI, undoHandler);
				}
				break;
			case DELETE_COMPLETE_EVENTS:
				if(noIndexArgument == true) {
					dataUI.setFeedback(FEEDBACK_PENDING_COMPLETE_EVENT_INDEX);
					return success = false;
				} else {
					success = performCompEventDelete(userIndex, fileLink, dataUI, undoHandler);
				}
				break;
			default:
				break;
		}
		return success;
	}

	private boolean performIncTaskDelete(String userIndex, FileLinker fileLink, DataUI dataUI, Undo undoHandler) {
		boolean success = true;
		ArrayList<TaskCard> incTasks = fileLink.getIncompleteTasks();
		
		try {
			int deletedIndex = Integer.parseInt(userIndex);
			
			if(deletedIndex <= 0 || deletedIndex > incTasks.size()) {
				dataUI.setFeedback(String.format(FEEDBACK_DELETION_RANGE, incTasks.size()));
				return success = false;
			} else {
				TaskCard task = incTasks.get(deletedIndex - 1);
				dataUI.setFeedback(String.format(FEEDBACK_DELETE_SUCCESSFUL, task.getName()));
				fileLink.deleteHandling(deletedIndex - 1, DELETE_INCOMPLETE_TASKS);
				
				undoHandler.storeUndo("delete", DELETE_INCOMPLETE_TASKS, task, null);
				RefreshUI.executeRefresh(fileLink, dataUI);
			}
		} catch(NumberFormatException ex) {
			dataUI.setFeedback(String.format(FEEDBACK_NOT_NUMBER_ENTERED, incTasks.size()));
			return success = false;
		}
		
		return success;
	}

	private boolean performIncEventDelete(String userIndex, FileLinker fileLink,
			DataUI dataUI, Undo undoHandler) {
		boolean success = true;
		ArrayList<TaskCard> incEvent = fileLink.getIncompleteEvents();
		
		try {
			int deletedIndex = Integer.parseInt(userIndex);
			
			if(deletedIndex < 0 || deletedIndex > incEvent.size()) {
				dataUI.setFeedback(String.format(FEEDBACK_DELETION_RANGE, incEvent.size()));
				return success = false;
			} else {
				TaskCard event = incEvent.get(deletedIndex - 1);
				dataUI.setFeedback(String.format(FEEDBACK_DELETE_SUCCESSFUL, event.getName()));
				fileLink.deleteHandling(deletedIndex - 1, DELETE_INCOMPLETE_EVENTS);
				
				undoHandler.storeUndo("delete", DELETE_INCOMPLETE_EVENTS, event, null);
				RefreshUI.executeRefresh(fileLink, dataUI);
			}
		} catch(NumberFormatException ex) {
			dataUI.setFeedback(String.format(FEEDBACK_NOT_NUMBER_ENTERED, incEvent.size()));
			success = false;
		}
		
		return success;
	}

	private boolean performCompTaskDelete(String userIndex, FileLinker fileLink, DataUI dataUI, Undo undoHandler) {
		boolean success = true;
		ArrayList<TaskCard> compTasks = fileLink.getCompletedTasks();
		
		try {
			int deletedIndex = Integer.parseInt(userIndex);
			
			if(deletedIndex < 0 || deletedIndex > compTasks.size()) {
				dataUI.setFeedback(String.format(FEEDBACK_DELETION_RANGE, compTasks.size()));
				return success = false;
			} else {
				TaskCard task = compTasks.get(deletedIndex - 1);
				dataUI.setFeedback(String.format(FEEDBACK_DELETE_SUCCESSFUL, task.getName()));
				fileLink.deleteHandling(deletedIndex - 1, DELETE_COMPLETE_TASK);
				
				undoHandler.storeUndo("delete", DELETE_COMPLETE_TASK, task, null);
				RefreshUI.executeRefresh(fileLink, dataUI);
			}
		} catch(NumberFormatException ex) {
			dataUI.setFeedback(String.format(FEEDBACK_NOT_NUMBER_ENTERED, compTasks.size()));
			return success = false;
		}
		
		return success;
	}

	private boolean performCompEventDelete(String userIndex, FileLinker fileLink,	DataUI dataUI, Undo undoHandler) {
		boolean success = true;
		ArrayList<TaskCard> compEvent = fileLink.getCompletedEvents();
		
		try {
			int deletedIndex = Integer.parseInt(userIndex);
			
			if(deletedIndex < 0 || deletedIndex > compEvent.size()) {
				dataUI.setFeedback(String.format(FEEDBACK_DELETION_RANGE, compEvent.size()));
				return success = false;
			} else {
				TaskCard event = compEvent.get(deletedIndex - 1);
				dataUI.setFeedback(String.format(FEEDBACK_DELETE_SUCCESSFUL, event.getName()));
				fileLink.deleteHandling(deletedIndex - 1, DELETE_COMPLETE_EVENTS);
				
				undoHandler.storeUndo("delete", DELETE_COMPLETE_EVENTS, event, null);
				RefreshUI.executeRefresh(fileLink, dataUI);
			}
		} catch(NumberFormatException ex) {
			dataUI.setFeedback(String.format(FEEDBACK_NOT_NUMBER_ENTERED, compEvent.size()));
			success = false;
		}
		
		return success;
	}

	private void notRecognisableCmd(FileLinker fileLink, DataUI dataUI) {
		RefreshUI.executeRefresh(fileLink, dataUI);
		dataUI.setFeedback(FEEDBACK_UNRECOGNISABLE_DELETE_COMMAND);
	}
	
	private void initialiseCmdTable() {
		cmdTable.put("del", 0);
		cmdTable.put("delt", DELETE_INCOMPLETE_TASKS);
		cmdTable.put("dele", DELETE_INCOMPLETE_EVENTS);
		cmdTable.put("deltc", DELETE_COMPLETE_TASK);
		cmdTable.put("delec", DELETE_COMPLETE_EVENTS);
	}
}

	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Delete.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Delete.java
	 */


	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Delete.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\DeleteTest.java
	 */

package application;
import static org.junit.Assert.*;

import org.junit.Test;

import java.io.IOException;

public class DeleteTest {

	@Test
	public void testExecuteDelete() throws IOException{
		/**
		 * For invalid command name without number input
		 */
		Undo undoHandler = new Undo();
		
		String wrongDelete = "delete";
		int tableNo = 1;
		FileLinker deleteFileLinker = new FileLinker();
		DataUI deleteUI = new DataUI();
		deleteUI.configIncompleteTasks(deleteFileLinker);
		Delete newDeleteWithWrongCommand = new Delete();
		
		newDeleteWithWrongCommand.executeDelete(wrongDelete, deleteFileLinker, deleteUI, tableNo, undoHandler);
		
		assertEquals("That was an unrecognisable delete command :(", deleteUI.getFeedback());
		
		/**
		 * For valid command name without number input
		 */
		
		String deleteIncompTaskNoID = "delt";
		tableNo = 1;
		FileLinker deleteFLForDTWithoutNum = new FileLinker();
		DataUI deleteUIForValidDeleteName = new DataUI();
		deleteUIForValidDeleteName.configIncompleteTasks(deleteFLForDTWithoutNum);
		Delete newDeleteForIncompTaskNoId = new Delete();
		newDeleteForIncompTaskNoId.executeDelete(deleteIncompTaskNoID, deleteFLForDTWithoutNum, deleteUIForValidDeleteName, tableNo, undoHandler);
		
		assertEquals("You didn't specify an incomplete task to delete! Please enter an ID to delete!", deleteUIForValidDeleteName.getFeedback());
	
		/**
		 * For valid command for type task 
		 */
		
		
		String deleteIncompTaskNo3 = "delt 3";
		tableNo = 1;
		FileLinker deleteFlTaskWithNum = new FileLinker();
		DataUI deleteUIForDtWithNum = new DataUI();
		deleteUIForDtWithNum.configIncompleteTasks(deleteFlTaskWithNum);
		Delete newDeleteForIncompTaskWithID = new Delete();
		newDeleteForIncompTaskWithID.executeDelete(deleteIncompTaskNo3, deleteFlTaskWithNum, deleteUIForDtWithNum, tableNo, undoHandler);
		
		assertEquals("\"hello world\" has been deleted!", deleteUIForDtWithNum.getFeedback());
		
		/**
		 * For valid command  for type event 
		 */
		
		String deleteIncompEventNo3 = "dele 3";
		tableNo = 2;
		FileLinker deleteFlEventWithNum = new FileLinker();
		DataUI deleteUIForDeWithNum = new DataUI();
		deleteUIForDeWithNum.configIncompleteEvents(deleteFlEventWithNum);
		Delete newDeleteForIncompEventWithID = new Delete();
		newDeleteForIncompEventWithID.executeDelete(deleteIncompEventNo3, deleteFlEventWithNum, deleteUIForDeWithNum, tableNo, undoHandler);
	
		assertEquals("\"test2\" has been deleted!", deleteUIForDeWithNum.getFeedback());
	
	
	}

}

	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\DeleteTest.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Edit.java
	 */

package application;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Calendar;
import java.util.Date;

public class Edit {
	
	
	private static final String FEEDBACK_IMPROPER_PRIORITY = "You didn't enter a proper priority!";
	private static final String FEEDBACK_EVENT_EDITED = "Event edited!";
	private static final String FEEDBACK_TASK_EDITED = "Task edited!";
	private static final String FEEDBACK_MISSING_DETAILS_TO_EDIT = "Are you missing the details that you want to edit?";
	private static final String FEEDBACK_MISSING_NUM_DETAILS = "Are you missing the task number and details you want to edit?";
	private static final String FEEDBACK_IMPROPER_DATE_TIME_FORMAT = "You didn't enter a proper date or time format!";
	private static final String FEEDBACK_MISSING_TIMING = "Did you enter a timing?";
	private static final String FEEDBACK_EXTRA_TIMING = "Did you enter an extra timing?";
	private static final String FEEDBACK_EXTRA_DETAILS = "Did you enter something extra?";
	private static final String FEEDBACK_MISSING_DETAILS = "Are you missing something?";
	private static final String FEEDBACK_ENTER_PROPER_RANGE = "Please enter a number between 1 to %d";
	private static final String FEEDBACK_NOTHING_TO_BE_EDITED = "There is nothing to be edited!";
	private static final String FEEDBACK_TASK_EDIT_SUCCESSFUL = "The task has been successfully edited!";
	private static final String FEEDBACK_EVENT_EDIT_SUCCESSFUL = "The event has been successfully edited!";
	private static final String FEEDBACK_UNRECOGNISABLE_EDIT_COMMAND = "That was an unrecognisable edit command :(";
	private static final String FEEDBACK_TIME_TRAVEL = "Greaaat Scott! Are you a time traveler?";

	private static final String TYPE_EDIT = "edit";
	
	private Calendar floatingDefaultEndDay = new GregorianCalendar(9999, 11, 31, 23, 59, 59);
	
	private static final int EDIT_BOTH_EVENTS_TASKS = 0;
	private static final int EDIT_INCOMPLETE_TASKS = 1;
	private static final int EDIT_INCOMPLETE_EVENTS = 2;
	private static final int FIRST_ARG = 0;
	private static final int SECOND_ARG = 1;
	
	private static final int TYPE_INC_TASKS = 1;
	private static final int TYPE_INC_EVENTS = 2;
	
	private static final int PRIORITY_LOW = 1;
	private static final int PRIORITY_MED = 2;
	private static final int PRIORITY_HIGH = 3;
	
	private static final int EDIT_NAME = 1;
	private static final int EDIT_PRIORITY = 2;
	private static final int EDIT_START = 3;
	private static final int EDIT_END = 4;
	
	private static final int START = 1;
	private static final int END = 2;
	
	private static final int EDITING_PRIORITY_HIGH = 3;
	private static final int EDITING_PRIORITY_MED = 2;
	private static final int EDITING_PRIORITY_LOW = 1;
	private static final int EDITING_END = 4;
	private static final int EDITING_START = 3;
	private static final int EDITING_PRIORITY = 2;
	private static final int EDITING_NAME = 1;
	
	private HashMap<String, Integer> cmdTable = new HashMap<String, Integer>();
	private HashMap<String, Integer> editTable = new HashMap<String, Integer>();
	private HashMap<String, Integer> priorityTable = new HashMap<String, Integer>();
	
	public Edit() {
		initialiseCmdTable();
		initialiseEditTable();
		intialisePriorityTable();
		
		floatingDefaultEndDay.set(Calendar.MILLISECOND, 999);
	}
	
	/**
	 * This method checks if the user input is of acceptable length and if the command entered is 
	 * valid. If it does it passes it to the next layer to understand and execute the command
	 * else it will prompt the user to check his input
	 * @param userInput
	 * @param fileLink
	 * @param dataUI
	 * @param tableNo
	 * @param undoHandler
	 * @param dateFormats
	 * @return
	 */
	
	public void executeEdit(String userInput, FileLinker fileLink, 
			DataUI dataUI, int tableNo, Undo undoHandler, 
			DateAndTimeFormats dateFormats) {
		boolean success = false;
		String[] tokenizedInput = userInput.trim().split("\\s+", 2);
		
		String cmd = tokenizedInput[FIRST_ARG];
		
		if(tokenizedInput.length < 2) {
			dataUI.setFeedback(FEEDBACK_MISSING_NUM_DETAILS);
			return;
		}
		
		if(cmdTable.containsKey(cmd) != true) {	
			notRecognisableCmd(fileLink, dataUI);
			return;
		} else {
			success = identifyCmdAndPerform(tokenizedInput, fileLink, dataUI, tableNo, undoHandler, dateFormats);
		}
		
		if(success) {
			undoHandler.flushRedo();
		}
		
		return;
	}
	
	/**
	 * This method checks if the input that comes after the edit command is of acceptable length and redirect the 
	 * input to the relevant other commands based on whether it is to edit tasks or events. 
	 * @param tokenizedInput
	 * @param fileLink
	 * @param dataUI
	 * @param tableNo
	 * @param undoHandler
	 * @param dateFormats
	 * @return
	 */
	
	private boolean identifyCmdAndPerform(String[] tokenizedInput, 
			FileLinker fileLink, DataUI dataUI, int tableNo, 
			Undo undoHandler, DateAndTimeFormats dateFormats) {
		boolean success = false;
		String cmd = tokenizedInput[FIRST_ARG];
		String[] indexAndDetails = tokenizedInput[SECOND_ARG].trim().split("\\s+", 2);
		
		if(indexAndDetails.length < 2) {
			dataUI.setFeedback(FEEDBACK_MISSING_DETAILS_TO_EDIT);
			return false;
		}
		
		switch(cmdTable.get(cmd)) {
			case EDIT_BOTH_EVENTS_TASKS:
				if(tableNo == EDIT_INCOMPLETE_TASKS) {
					success = checkIndexIncTaskEdit(indexAndDetails, fileLink, dataUI, undoHandler, dateFormats);
				} else if(tableNo == EDIT_INCOMPLETE_EVENTS){
					success = checkIndexIncEventEdit(indexAndDetails, fileLink, dataUI, undoHandler, dateFormats);
				}
				break;
			case EDIT_INCOMPLETE_TASKS:
				success = checkIndexIncTaskEdit(indexAndDetails, fileLink, dataUI, undoHandler, dateFormats);
				break;
			case EDIT_INCOMPLETE_EVENTS:
				success = checkIndexIncEventEdit(indexAndDetails, fileLink, dataUI, undoHandler, dateFormats);
				break;
			default:
				break;
		}
		
		return success;		
	}
	
	/**
	 * This method checks to see if the index enter for editing an incomplete task is within the range of tasks that exist and if it
	 * is relays the information to the next methof
	 * @param indexAndDetails
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param dateFormats
	 * @return
	 */
	
	private boolean checkIndexIncTaskEdit(String[] indexAndDetails, FileLinker fileLink, 
			DataUI dataUI, Undo undoHandler, DateAndTimeFormats dateFormats) {
		ArrayList<TaskCard> incTasks = fileLink.getIncompleteTasks();
		int indexToBeEdited = getIndex(indexAndDetails[FIRST_ARG]);
		boolean success = false;
		
		if(incTasks.size() == 0) {
			dataUI.setFeedback(FEEDBACK_NOTHING_TO_BE_EDITED);
			return false;
		}
		
		if(indexToBeEdited < 0 || indexToBeEdited > incTasks.size()) {
			dataUI.setFeedback(String.format(FEEDBACK_ENTER_PROPER_RANGE, incTasks.size()));
			return false;
		}
		
		String paramAndDetails = indexAndDetails[SECOND_ARG];
		success = identifyTaskParams(paramAndDetails, fileLink, dataUI, undoHandler, dateFormats, indexToBeEdited);
		return success;
	}
	/**
	 * This method checks the if the input after the index is of acceptable length. If it is, it tries to recognize
	 * what parameter the user wishes to edit
	 * @param paramAndDetails
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param dateFormats
	 * @param indexToBeEdited
	 * @return
	 */
	private boolean identifyTaskParams(String paramAndDetails, FileLinker fileLink, 
			DataUI dataUI, Undo undoHandler, DateAndTimeFormats dateFormats, int indexToBeEdited) {
		boolean success = false;
		String[] paramAndDetailsSplit = paramAndDetails.trim().split(":", 2);
		
		if(paramAndDetailsSplit.length < 2) {
			dataUI.setFeedback(FEEDBACK_MISSING_DETAILS);
			return false;
		} else if(paramAndDetailsSplit.length > 2) {
			dataUI.setFeedback(FEEDBACK_EXTRA_DETAILS);
			return false;
		}
		
		String param = paramAndDetailsSplit[FIRST_ARG].toLowerCase().trim();
		switch(editTable.get(param)) {
			case EDIT_NAME:
				success = editName(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, TYPE_INC_TASKS);
				break;
			case EDIT_PRIORITY:
				success = editPriority(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, TYPE_INC_TASKS);
				break;
			case EDIT_END:
				success = editTaskEnd(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, dateFormats);
				break;
			default:
				break;
		}
		
		return success;
	}
	
	/**
	 * This method checks if the input is to set an end time and date or if the input is meant to change a timed task to a floating task
	 * and then calls the functions required to make the change based on this input
	 * @param date
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param dateFormats
	 * @return
	 */
	
	private boolean editTaskEnd(String date, FileLinker fileLink,
			DataUI dataUI, Undo undoHandler, int indexToBeEdited, DateAndTimeFormats dateFormats) {
		boolean success = false;
		
		if(date.trim().equals("-") || date.trim().equals("none") || date.trim().equals("nil")) {
			editToFloatingTask(fileLink, dataUI, undoHandler, indexToBeEdited);
			return true;
		}
		
		String[] dateAndTime = date.trim().split(",");
		
		if(dateAndTime.length < 1) {
			dataUI.setFeedback(FEEDBACK_MISSING_TIMING);
			return false;
		} else if(dateAndTime.length > 2) {
			dataUI.setFeedback(FEEDBACK_EXTRA_TIMING);
			return false;
		}
		
		if(dateAndTime.length == 1) {
			Date dateEntered = getDate(dateAndTime[FIRST_ARG], dateFormats);
			Date timeEntered = getTime(dateAndTime[FIRST_ARG], dateFormats);
			
			if(dateEntered == null && timeEntered == null) {
				dataUI.setFeedback(FEEDBACK_IMPROPER_DATE_TIME_FORMAT);
			} else if(dateEntered != null && timeEntered != null) {
				dataUI.setFeedback(FEEDBACK_IMPROPER_DATE_TIME_FORMAT);
			} else if(timeEntered != null) {
				success = editTaskTimeAndAdd(timeEntered, fileLink, dataUI, undoHandler, indexToBeEdited);
			} else {
				success = editTaskDateAndAdd(dateEntered, fileLink, dataUI, undoHandler, indexToBeEdited);
			}
		} else if(dateAndTime.length == 2) {
			Date dateAndTimeEntered = getDateAndTime(dateAndTime, dateFormats);
			
			if(dateAndTimeEntered == null) {
				dataUI.setFeedback(FEEDBACK_IMPROPER_DATE_TIME_FORMAT);
				return false;
			}
			success = editTaskDateAndTimeAdd(dateAndTimeEntered, fileLink, dataUI, undoHandler, indexToBeEdited);
		}
		return success;
	}
	
	/**
	 * This input make a timed task a floating task 
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 */
	
	private void editToFloatingTask(FileLinker fileLink, DataUI dataUI,
			Undo undoHandler, int indexToBeEdited) {
		TaskCard origTask = fileLink.getIncompleteTasks().get(indexToBeEdited - 1);
		TaskCard replacementTask = (TaskCard) origTask.clone();
		
		replacementTask.setEndDay(floatingDefaultEndDay);
		replacementTask.setType("FT");
		
		fileLink.editHandling(replacementTask, indexToBeEdited - 1, TYPE_INC_TASKS);
		undoHandler.storeUndo(TYPE_EDIT, EDIT_INCOMPLETE_TASKS, origTask, replacementTask);
		dataUI.setFeedback(FEEDBACK_TASK_EDIT_SUCCESSFUL);
		RefreshUI.executeRefresh(fileLink, dataUI);
	}
	
	/**
	 * This method will change the end date and time for the task that the user has entered and change the type of the 
	 * task to that of a floating task
	 * @param dateAndTimeEntered
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @return
	 */
	private boolean editTaskDateAndTimeAdd(Date dateAndTimeEntered,
			FileLinker fileLink, DataUI dataUI, Undo undoHandler, int indexToBeEdited) {
		boolean success = true;
		TaskCard origTask = fileLink.getIncompleteTasks().get(indexToBeEdited - 1);
		TaskCard replacementTask = (TaskCard) origTask.clone();
		
		Calendar endDateAndTimeEdited = GregorianCalendar.getInstance();
		endDateAndTimeEdited.setTime(dateAndTimeEntered);
		
		replacementTask.setEndDay(endDateAndTimeEdited);
		replacementTask.setType("T");
		
		fileLink.editHandling(replacementTask, indexToBeEdited - 1, EDIT_INCOMPLETE_TASKS);
		undoHandler.storeUndo(TYPE_EDIT, EDIT_INCOMPLETE_TASKS, origTask, replacementTask);
		dataUI.setFeedback(FEEDBACK_TASK_EDIT_SUCCESSFUL);
		RefreshUI.executeRefresh(fileLink, dataUI);
		return success;
	}
	
	/**
	 * This method will only change the end date of a task and change the type of the task to that of a timed task
	 * @param dateEntered
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @return
	 */
	
	private boolean editTaskDateAndAdd(Date dateEntered, FileLinker fileLink,
			DataUI dataUI, Undo undoHandler, int indexToBeEdited) {
		boolean success = true;
		TaskCard origTask = fileLink.getIncompleteTasks().get(indexToBeEdited - 1);
		TaskCard replacementTask = (TaskCard) origTask.clone();
		
		Calendar endDateEdited = GregorianCalendar.getInstance();
		endDateEdited.setTime(dateEntered);
		
		if(origTask.getType().equals("T")) {
			endDateEdited.set(Calendar.HOUR_OF_DAY, origTask.getEndDay().get(Calendar.HOUR_OF_DAY));
			endDateEdited.set(Calendar.MINUTE, origTask.getEndDay().get(Calendar.MINUTE));
			endDateEdited.set(Calendar.SECOND, origTask.getEndDay().get(Calendar.SECOND));
			endDateEdited.set(Calendar.MILLISECOND, origTask.getEndDay().get(Calendar.MILLISECOND));
		} else {
			endDateEdited.set(Calendar.HOUR_OF_DAY, 0);
			endDateEdited.set(Calendar.MINUTE, 0);
			endDateEdited.set(Calendar.SECOND, 0);
			endDateEdited.set(Calendar.MILLISECOND, 0);
		}
		
		replacementTask.setEndDay(endDateEdited);
		replacementTask.setType("T");
		
		fileLink.editHandling(replacementTask, indexToBeEdited - 1, EDIT_INCOMPLETE_TASKS);
		undoHandler.storeUndo(TYPE_EDIT, EDIT_INCOMPLETE_TASKS, origTask, replacementTask);
		dataUI.setFeedback(FEEDBACK_TASK_EDIT_SUCCESSFUL);
		RefreshUI.executeRefresh(fileLink, dataUI);
		
		return success;
	}
	/**
	 * This method will only change the time of the task to the one that was entered by the user, the end date is set to be 
	 * the date that the user is currently using TaskWorthy on
	 * @param timeEntered
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @return
	 */
	private boolean editTaskTimeAndAdd(Date timeEntered, FileLinker fileLink,
			DataUI dataUI, Undo undoHandler, int indexToBeEdited) {
		boolean success = true;
		TaskCard origTask = fileLink.getIncompleteTasks().get(indexToBeEdited - 1);
		TaskCard replacementTask = (TaskCard) origTask.clone();
		
		Calendar endDateEdited = GregorianCalendar.getInstance();
		endDateEdited.setTime(timeEntered);
		
		if(origTask.getType() == "T") {
			endDateEdited.set(Calendar.DATE, origTask.getEndDay().get(Calendar.DATE));
			endDateEdited.set(Calendar.MONTH, origTask.getEndDay().get(Calendar.MONTH));
			endDateEdited.set(Calendar.YEAR, origTask.getEndDay().get(Calendar.YEAR));
		}
		
		replacementTask.setEndDay(endDateEdited);
		replacementTask.setType("T");
		
		fileLink.editHandling(replacementTask, indexToBeEdited - 1, EDIT_INCOMPLETE_TASKS);
		undoHandler.storeUndo(TYPE_EDIT, EDIT_INCOMPLETE_TASKS, origTask, replacementTask);
		dataUI.setFeedback(FEEDBACK_TASK_EDIT_SUCCESSFUL);
		RefreshUI.executeRefresh(fileLink, dataUI);
		
		return success;
	}
	/**
	 * This method checks if the event index that the user wants to edit is within the range of incomplete events
	 * @param indexAndDetails
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param dateFormats
	 * @return
	 */
	private boolean checkIndexIncEventEdit(String[] indexAndDetails, FileLinker fileLink, 
			DataUI dataUI, Undo undoHandler, DateAndTimeFormats dateFormats) {	
		boolean success = false;
		ArrayList<TaskCard> incEvents = fileLink.getIncompleteEvents();
		int indexToBeEdited = getIndex(indexAndDetails[FIRST_ARG]);
		
		if(incEvents.size() == 0) {
			dataUI.setFeedback(FEEDBACK_NOTHING_TO_BE_EDITED);
			return false;
		}
		
		if(indexToBeEdited < 0 || indexToBeEdited > incEvents.size()) {
			dataUI.setFeedback(String.format(FEEDBACK_ENTER_PROPER_RANGE, incEvents.size()));
			return false;
		}
		
		String paramAndDetails = indexAndDetails[SECOND_ARG];
		success = identifyEventParams(paramAndDetails, fileLink, dataUI, undoHandler, dateFormats, indexToBeEdited);
		return success;
	}
	
	/**
	 * This method checks if the input after the event index is of acceptable length and if so checks to see if
	 * the parameter the user wants to edit is valid, in which case it redirects the input to the relevant methods
	 * @param paramAndDetails
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param dateFormats
	 * @param indexToBeEdited
	 * @return
	 */
	private boolean identifyEventParams(String paramAndDetails,
			FileLinker fileLink, DataUI dataUI, Undo undoHandler,
			DateAndTimeFormats dateFormats, int indexToBeEdited) {
		boolean success = false;
		String[] paramAndDetailsSplit = paramAndDetails.trim().split(":");
		
		if(paramAndDetailsSplit.length < 2) {
			dataUI.setFeedback(FEEDBACK_MISSING_DETAILS);
			return false;
		} else if(paramAndDetailsSplit.length > 2) {
			dataUI.setFeedback(FEEDBACK_EXTRA_DETAILS);
			return false;
		}
		
		String param = paramAndDetailsSplit[FIRST_ARG].toLowerCase().trim();
		switch(editTable.get(param)) {
			case EDIT_NAME:
				success = editName(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, TYPE_INC_EVENTS);
				break;
			case EDIT_PRIORITY:
				success = editPriority(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, TYPE_INC_EVENTS);
				break;
			case EDIT_START:
				success = editEventTiming(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, dateFormats, 1);
				break;
			case EDIT_END:
				success = editEventTiming(paramAndDetailsSplit[SECOND_ARG], fileLink, dataUI, undoHandler, indexToBeEdited, dateFormats, 2);
				break;
			default:
				break;
		}
		return success;
	}
	/**
	 * This method edits the input entered after the recognized keywords of start and end are of acceptable length
	 * and checks whether the user wishes to edit both the date and time, just the date or just the time and redirects the 
	 * input accordingly.
	 * @param date
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param dateFormats
	 * @param timing
	 * @return
	 */
	private boolean editEventTiming(String date, FileLinker fileLink,
			DataUI dataUI, Undo undoHandler, int indexToBeEdited, DateAndTimeFormats dateFormats, int timing) {
		boolean success = false;
		
		String[] dateAndTime = date.trim().split(",");
		
		if(dateAndTime.length < 1) {
			dataUI.setFeedback(FEEDBACK_MISSING_TIMING);
			return false;
		} else if(dateAndTime.length > 2) {
			dataUI.setFeedback(FEEDBACK_EXTRA_TIMING);
			return false;
		}
		
		if(dateAndTime.length == 1) {
			Date dateEntered = getDate(dateAndTime[FIRST_ARG], dateFormats);
			Date timeEntered = getTime(dateAndTime[FIRST_ARG], dateFormats);
			
			if(dateEntered == null && timeEntered == null) {
				dataUI.setFeedback(FEEDBACK_IMPROPER_DATE_TIME_FORMAT);
			} else if(dateEntered != null && timeEntered != null) {
				dataUI.setFeedback(FEEDBACK_IMPROPER_DATE_TIME_FORMAT);
			} else if(timeEntered != null) {
				success = editEventTimeAndAdd(timeEntered, fileLink, dataUI, undoHandler, indexToBeEdited, timing);
			} else {
				success = editEventDateAndAdd(dateEntered, fileLink, dataUI, undoHandler, indexToBeEdited, timing);
			}
		} else if(dateAndTime.length == 2) {
			Date dateAndTimeEntered = getDateAndTime(dateAndTime, dateFormats);
			if(dateAndTimeEntered == null) {
				dataUI.setFeedback(FEEDBACK_IMPROPER_DATE_TIME_FORMAT);
				return false;
			}
			success = editEventDateAndTimeAdd(dateAndTimeEntered, fileLink, dataUI, undoHandler, indexToBeEdited, timing);
		}
		return success;
	}
	/**
	 * This method changes the time of the event and depending on what type of event it is, changes it to a Timed event if it is an
	 * all day event 
	 * @param timeEntered
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param typeTiming
	 * @return
	 */
	
	private boolean editEventTimeAndAdd(Date timeEntered, FileLinker fileLink,
      DataUI dataUI, Undo undoHandler, int indexToBeEdited, int typeTiming) {
		boolean success = true;
		TaskCard origEvent = fileLink.getIncompleteEvents().get(indexToBeEdited - 1);
		TaskCard replacementEvent = (TaskCard) origEvent.clone();
		
		if(typeTiming == START) {
			Calendar start = GregorianCalendar.getInstance();
			start.setTime(timeEntered);
			start.set(Calendar.DATE, origEvent.getStartDay().get(Calendar.DATE));
			start.set(Calendar.MONTH, origEvent.getStartDay().get(Calendar.MONTH));
			start.set(Calendar.YEAR, origEvent.getStartDay().get(Calendar.YEAR));
			
			replacementEvent.setStartDay(start);
			replacementEvent.setType("E");
		} else if(typeTiming == END) {
			Calendar end = GregorianCalendar.getInstance();
			end.setTime(timeEntered);
			end.set(Calendar.DATE, origEvent.getEndDay().get(Calendar.DATE));
			end.set(Calendar.MONTH, origEvent.getEndDay().get(Calendar.MONTH));
			end.set(Calendar.YEAR, origEvent.getEndDay().get(Calendar.YEAR));
			
			replacementEvent.setEndDay(end);
			replacementEvent.setType("E");
		}
		
		if(replacementEvent.getStartDay().after(replacementEvent.getEndDay())) {
			dataUI.setFeedback(FEEDBACK_TIME_TRAVEL);
			return false;
		}
		
		fileLink.editHandling(replacementEvent, indexToBeEdited - 1, TYPE_INC_EVENTS);
		dataUI.setFeedback(FEEDBACK_EVENT_EDIT_SUCCESSFUL);
		undoHandler.storeUndo(TYPE_EDIT, TYPE_INC_EVENTS, origEvent, replacementEvent);
		RefreshUI.executeRefresh(fileLink, dataUI);
		return success;
  }
	
	/**
	 * This method only changes the event date of the event that the user wishes to change
	 * @param dateEntered
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param typeTiming
	 * @return
	 */

	private boolean editEventDateAndAdd(Date dateEntered, FileLinker fileLink,
      DataUI dataUI, Undo undoHandler, int indexToBeEdited, int typeTiming) {
		boolean success = true;
		TaskCard origEvent = fileLink.getIncompleteEvents().get(indexToBeEdited - 1);
		TaskCard replacementEvent = (TaskCard) origEvent.clone();
		
		if(typeTiming == START) {
			Calendar start = GregorianCalendar.getInstance();
			start.setTime(dateEntered);
			start.set(Calendar.HOUR_OF_DAY, origEvent.getStartDay().get(Calendar.HOUR_OF_DAY));
			start.set(Calendar.MINUTE, origEvent.getStartDay().get(Calendar.MINUTE));
			start.set(Calendar.SECOND, origEvent.getStartDay().get(Calendar.SECOND));
			start.set(Calendar.MILLISECOND, origEvent.getStartDay().get(Calendar.MILLISECOND));
			
			replacementEvent.setStartDay(start);
			if(origEvent.getType().equals("AE")) {
				replacementEvent.setType("AE");
			} else {
				replacementEvent.setType("E");
			}
		} else if(typeTiming == END) {
			Calendar end = GregorianCalendar.getInstance();
			end.setTime(dateEntered);
			end.set(Calendar.HOUR_OF_DAY, origEvent.getEndDay().get(Calendar.HOUR_OF_DAY));
			end.set(Calendar.MINUTE, origEvent.getEndDay().get(Calendar.MINUTE));
			end.set(Calendar.SECOND, origEvent.getEndDay().get(Calendar.SECOND));
			end.set(Calendar.MILLISECOND, origEvent.getEndDay().get(Calendar.MILLISECOND));
			
			replacementEvent.setEndDay(end);
			if(origEvent.getType().equals("AE")) {
				replacementEvent.setType("AE");
			} else {
				replacementEvent.setType("E");
			}
		}
		
		if(replacementEvent.getStartDay().after(replacementEvent.getEndDay())) {
			dataUI.setFeedback(FEEDBACK_TIME_TRAVEL);
			return false;
		}
		
		fileLink.editHandling(replacementEvent, indexToBeEdited - 1, TYPE_INC_EVENTS);
		dataUI.setFeedback(FEEDBACK_EVENT_EDIT_SUCCESSFUL);
		undoHandler.storeUndo(TYPE_EDIT, TYPE_INC_EVENTS, origEvent, replacementEvent);
		RefreshUI.executeRefresh(fileLink, dataUI);
		return success;
  }
	
	/**
	 * This method just changes the date of the event
	 * @param dateAndTimeEntered
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param typeTiming
	 * @return
	 */

	private boolean editEventDateAndTimeAdd(Date dateAndTimeEntered,
      FileLinker fileLink, DataUI dataUI, Undo undoHandler,
      int indexToBeEdited, int typeTiming) {
		boolean success = true;
		TaskCard origEvent = fileLink.getIncompleteEvents().get(indexToBeEdited - 1);
		TaskCard replacementEvent = (TaskCard) origEvent.clone();
		
		if(typeTiming == START) {
			Calendar start = GregorianCalendar.getInstance();
			start.setTime(dateAndTimeEntered);
			
			replacementEvent.setStartDay(start);
			replacementEvent.setType("E");
		} else if(typeTiming == END) {
			Calendar end = GregorianCalendar.getInstance();
			end.setTime(dateAndTimeEntered);
			
			replacementEvent.setEndDay(end);
			replacementEvent.setType("E");
		}
		
		if(replacementEvent.getStartDay().after(replacementEvent.getEndDay())) {
			dataUI.setFeedback(FEEDBACK_TIME_TRAVEL);
			return false;
		}
		
		fileLink.editHandling(replacementEvent, indexToBeEdited - 1, TYPE_INC_EVENTS);
		dataUI.setFeedback(FEEDBACK_EVENT_EDIT_SUCCESSFUL);
		undoHandler.storeUndo(TYPE_EDIT, TYPE_INC_EVENTS, origEvent, replacementEvent);
		RefreshUI.executeRefresh(fileLink, dataUI);
		return success;
  }

	/**
	 * This method changes the name of the task or event
	 * @param name
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param type
	 * @return
	 */
	private boolean editName(String name, FileLinker fileLink, DataUI dataUI,
			Undo undoHandler, int indexToBeEdited, int type) {
		boolean success = true;
		ArrayList<TaskCard> fileToBeEdited = new ArrayList<TaskCard>();
		
		if(type == TYPE_INC_TASKS) {
			fileToBeEdited = fileLink.getIncompleteTasks();
		} else {
			fileToBeEdited = fileLink.getIncompleteEvents();
		}
		
		TaskCard origTask = fileToBeEdited.get(indexToBeEdited - 1);
		TaskCard editedTask = (TaskCard) origTask.clone();
		
		editedTask.setName(name.trim());
		
		if(type == TYPE_INC_TASKS) {
			dataUI.setFeedback(FEEDBACK_TASK_EDITED);
		} else {
			dataUI.setFeedback(FEEDBACK_EVENT_EDITED);
		}
		
		fileLink.editHandling(editedTask, indexToBeEdited - 1, type);
		undoHandler.storeUndo(TYPE_EDIT, type, origTask, editedTask);
		RefreshUI.executeRefresh(fileLink, dataUI);
		
		return success;
	}
	
	/**
	 * This method checks if the priority level the user wishes to change is of relevant format and if it is, changes it
	 * @param priority
	 * @param fileLink
	 * @param dataUI
	 * @param undoHandler
	 * @param indexToBeEdited
	 * @param type
	 * @return
	 */
	private boolean editPriority(String priority, FileLinker fileLink,
			DataUI dataUI, Undo undoHandler, int indexToBeEdited, int type) {
		boolean success = false;
		priority = priority.trim();
		ArrayList<TaskCard> fileToBeEdited = new ArrayList<TaskCard>();
		
		if(!priorityTable.containsKey(priority)) {
			dataUI.setFeedback(FEEDBACK_IMPROPER_PRIORITY);
			return false;
		}
		
		if(type == TYPE_INC_TASKS) {
			fileToBeEdited = fileLink.getIncompleteTasks();
		} else {
			fileToBeEdited = fileLink.getIncompleteEvents();
		}
		
		TaskCard origTask = fileToBeEdited.get(indexToBeEdited - 1);
		TaskCard editedTask = (TaskCard) origTask.clone();
		
		switch(priorityTable.get(priority)) {
			case PRIORITY_LOW:
				editedTask.setPriority(PRIORITY_LOW);
				break;
			case PRIORITY_MED:
				editedTask.setPriority(PRIORITY_MED);
				break;
			case PRIORITY_HIGH:
				editedTask.setPriority(PRIORITY_HIGH);
				break;
			default: 
				break;
		}
		
		if(type == TYPE_INC_TASKS) {
			dataUI.setFeedback(FEEDBACK_TASK_EDITED);
		} else {
			dataUI.setFeedback(FEEDBACK_EVENT_EDITED);
		}
		
		fileLink.editHandling(editedTask, indexToBeEdited - 1, type);
		undoHandler.storeUndo(TYPE_EDIT, type, origTask, editedTask);
		RefreshUI.executeRefresh(fileLink, dataUI);
		success = true;
		
		return success;
	}
	
	private Date getDate(String string, DateAndTimeFormats dateFormats) {
		Date date = null;
		string = string.trim();
		if(dateFormats.isLazyDate(string) != null) {
			date = dateFormats.isLazyDate(string);
		} else if(dateFormats.isLazyYearDate(string) != null) {
			date = dateFormats.isLazyYearDate(string);
		} else if(dateFormats.isProperDate(string) != null) {
			date = dateFormats.isProperDate(string); 
		}
		return date;
	}
	
	private Date getTime(String string, DateAndTimeFormats dateFormats) {
		Date time = null;
		string = string.trim();
		if(dateFormats.isHourOnly(string) != null) {
			time = dateFormats.isHourOnly(string);
		} else if(dateFormats.isComplete12Hr(string) != null) {
			time = dateFormats.isComplete12Hr(string);
		} else if(dateFormats.isComplete24Hr(string) != null) {
			time = dateFormats.isComplete24Hr(string);
		}
		
		return time;
	}
	
	@SuppressWarnings("deprecation")
	private Date getDateAndTime(String[] dateAndTime, DateAndTimeFormats dateFormats) {
		String dateComponent = dateAndTime[FIRST_ARG].trim();
		String timeComponent = dateAndTime[SECOND_ARG].trim();
		Date time = null;
		Date date = null;
		
		if(dateFormats.isHourOnly(timeComponent) != null) {
			time = dateFormats.isHourOnly(timeComponent);
		} else if(dateFormats.isComplete12Hr(timeComponent) != null) {
			time = dateFormats.isComplete12Hr(timeComponent);
		} else if(dateFormats.isComplete24Hr(timeComponent) != null) {
			time = dateFormats.isComplete24Hr(timeComponent);
		}
		
		if(dateFormats.isLazyYearDate(dateComponent) != null) {
			date = dateFormats.isLazyYearDate(dateComponent);
		} else if(dateFormats.isProperDate(dateComponent) != null) {
			date = dateFormats.isProperDate(dateComponent); 
		} else if(dateFormats.isLazyDate(dateComponent) != null) {
			date = dateFormats.isLazyDate(dateComponent);
		}
		
		if(time == null || date == null) {
			return null;
		}
		
		Calendar cal = GregorianCalendar.getInstance();
		cal.setTime(date);
		cal.set(Calendar.HOUR_OF_DAY, time.getHours());
		cal.set(Calendar.MINUTE, time.getMinutes());
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		
		return cal.getTime();
	}
	
	private void notRecognisableCmd(FileLinker fileLink, DataUI dataUI) {		
		RefreshUI.executeRefresh(fileLink, dataUI);		
		dataUI.setFeedback(FEEDBACK_UNRECOGNISABLE_EDIT_COMMAND);		
	}
	
	private int getIndex(String string) {
		try {
			int index = Integer.parseInt(string);
			return index;
		} catch(NumberFormatException e) {
			return -1;
		}
	}
	
	private void initialiseCmdTable() {
		cmdTable.put("edit", EDIT_BOTH_EVENTS_TASKS);
		cmdTable.put("editt", EDIT_INCOMPLETE_TASKS);		
		cmdTable.put("edite", EDIT_INCOMPLETE_EVENTS);		
	}
	
	private void initialiseEditTable() {
		editTable.put("name", EDITING_NAME);
		editTable.put("priority", EDITING_PRIORITY);
		editTable.put("start", EDITING_START);
		editTable.put("end", EDITING_END);
	}
	
	private void intialisePriorityTable() {
		priorityTable.put("low", EDITING_PRIORITY_LOW);
		priorityTable.put("Low", EDITING_PRIORITY_LOW);
		priorityTable.put("med", EDITING_PRIORITY_MED);
		priorityTable.put("medium", EDITING_PRIORITY_MED);
		priorityTable.put("Med", EDITING_PRIORITY_MED);
		priorityTable.put("Medium", EDITING_PRIORITY_MED);
		priorityTable.put("high", EDITING_PRIORITY_HIGH);
		priorityTable.put("High", EDITING_PRIORITY_HIGH);
	}
}
	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Edit.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Edit.java
	 */

	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\Edit.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\EventDataUI.java
	 */

package application;

import javafx.beans.property.SimpleStringProperty;

public class EventDataUI {

	private SimpleStringProperty ID; 
	private SimpleStringProperty Priority;
	private SimpleStringProperty Name;
	private SimpleStringProperty startDate;
	private SimpleStringProperty startTime;
	private SimpleStringProperty endDate;
	private SimpleStringProperty endTime;
	private boolean isExpired;
	private boolean isOngoing;
	
	public EventDataUI() {
		this.ID = new SimpleStringProperty();
		this.Priority = new SimpleStringProperty();
		this.Name = new SimpleStringProperty();
		this.startDate = new SimpleStringProperty();
		this.startTime = new SimpleStringProperty();
		this.endDate = new SimpleStringProperty();
		this.endTime = new SimpleStringProperty();
		this.isExpired = false;
		this.isOngoing = false;
	}
	
	public String getID() {
		return ID.get();
	}
	
	public void setID(String id) {
		ID.set(id);
	}
	
	public String getPriority() {
		return Priority.get();
	}
	
	public void setPriority(String p) {
		Priority.set(p);
	}
	
	public String getName() {
		return Name.get();
	}
	
	public void setName(String n) {
		Name.set(n);
	}
	
	public String getStartDate() {
		return startDate.get();
	}
	
	public void setStartDate(String startD) {
		startDate.set(startD);
	}
	
	public String getStartTime() {
		return startTime.get();
	}
	
	public void setStartTime(String startT) {
		startTime.set(startT);
	}
	
	public String getEndDate() {
		return endDate.get();
	}
	
	public void setEndDate(String endD) {
		endDate.set(endD);
	}
	
	public String getEndTime() {
		return endTime.get();
	}
	
	public void setEndTime(String endT) {
		endTime.set(endT);
	}
	
	public boolean getIsExpired() {
		return isExpired;
	}
	
	public void setIsExpired(boolean isEx) {
		isExpired = isEx;
	}
	
	public boolean getIsOngoing() {
		return isOngoing;
	}
	
	public void setIsOngoing(boolean isOn) {
		isOngoing = isOn;
	}
	
	public SimpleStringProperty idProperty() {
		return ID;
	}
	
	public SimpleStringProperty priorityProperty() {
		return Priority;
	}
	
	public SimpleStringProperty nameProperty() {
		return Name;
	}
	
	public SimpleStringProperty startDateProperty() {
		return startDate;
	}
	
	public SimpleStringProperty startTimeProperty() {
		return startTime;
	}
	
	public SimpleStringProperty endDateProperty() {
		return endDate;
	}
	
	public SimpleStringProperty endTimeProperty() {
		return endTime;
	}
}
	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\EventDataUI.java





	/**
	 * origin: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\TaskDataUI.java
	 */

package application;

import javafx.beans.property.SimpleStringProperty;

public class TaskDataUI {

	private SimpleStringProperty ID;    
	private SimpleStringProperty priority;
	private SimpleStringProperty name;
	private SimpleStringProperty endDate;
	private SimpleStringProperty endTime;
	private boolean isExpired;
	
	public TaskDataUI() {
		this.ID = new SimpleStringProperty();
		this.priority = new SimpleStringProperty();
		this.name = new SimpleStringProperty();
		this.endDate = new SimpleStringProperty();
		this.endTime = new SimpleStringProperty();
		this.isExpired = false;
	}

	public String getID() {
		return ID.get();
	}
	
	public void setID(String id) {
		ID.set(id);
	}
	
	public String getPriority() {
		return priority.get();
	}
	
	public void setPriority(String p) {
		priority.set(p);
	}
	
	public String getName() {
		return name.get();
	}
	
	public void setName(String n) {
		name.set(n);
	}
	
	public void setIsExpired(boolean expired) {
		isExpired = expired;
	}
	
	public String getEndDate() {
		return endDate.get();
	}
	
	public void setEndDate(String endD) {
		endDate.set(endD);
	}
	
	public String getEndTime() {
		return endTime.get();
	}
	
	public void setEndTime(String endT) {
		endTime.set(endT);
	}
	
	public SimpleStringProperty idProperty() {
		return ID;
	}
	
	public SimpleStringProperty priorityProperty() {
		return priority;
	}
	
	public SimpleStringProperty nameProperty() {
		return name;
	}
	
	public SimpleStringProperty endDateProperty() {
		return endDate;
	}
	
	public SimpleStringProperty endTimeProperty() {
		return endTime;
	}
	
	public boolean getIsExpired() {
		return isExpired;
	}
}

	// End of segment: C:\Users\Omar Khalid\workspace\TaskWorthy\src\application\TaskDataUI.java





